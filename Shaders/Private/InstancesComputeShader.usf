#include "/Engine/Public/Platform.ush"

RWStructuredBuffer<float4> SpawnPositions;
Texture2D<float> SceneDepthTexture;
Texture2D<float4> StencilTexture; // RGBA from post-process material
SamplerState SceneDepthSampler;
SamplerState StencilSampler;

float3 CameraPosition;
float3 CameraForward;
float3 CameraRight;
float3 CameraUp;
float OrthoWidth;
float OrthoHeight;
uint NumInstances;
float GridCellSize;
float SpawnDensity;
float VerticalOffset;
float MaxRayDistance;
uint TargetStencilValue; // Stencil value to filter (e.g., 250)

float Hash2D(float2 p)
{
    return frac(sin(dot(p, float2(127.1, 311.7))) * 43758.5453123);
}

[numthreads(64, 1, 1)]
void MainCS(uint3 ThreadId : SV_DispatchThreadID)
{
    uint Index = ThreadId.x;
    
    if (Index >= NumInstances)
        return;
    
    // Calculate grid position
    uint GridWidth = (uint)sqrt((float)NumInstances);
    uint GridHeight = GridWidth;
    
    uint GridX = Index % GridWidth;
    uint GridY = Index / GridWidth;
    
    // Calculate base UV coordinates
    float2 uv;
    uv.x = ((float)GridX + 0.5) / (float)GridWidth;
    uv.y = ((float)GridY + 0.5) / (float)GridHeight;
    
    // Apply jitter for randomization
    float2 gridSeed = float2((float)GridX, (float)GridY);
    float jitterX = (Hash2D(gridSeed) - 0.5) / (float)GridWidth;
    float jitterY = (Hash2D(gridSeed + float2(42.0, 13.0)) - 0.5) / (float)GridHeight;
    
    uv.x += jitterX;
    uv.y += jitterY;
    uv = saturate(uv);
    
    // Sample stencil value (stored in R channel, normalized 0-1)
    float4 stencilColor = StencilTexture.SampleLevel(StencilSampler, uv, 0);
    float stencilValue = stencilColor.r;
    
    // Check if this pixel belongs to our target mesh (voxel terrain)
    bool isTargetMesh = (stencilValue == TargetStencilValue);
    
    // Sample depth directly from texture
    float depth = SceneDepthTexture.SampleLevel(SceneDepthSampler, uv, 0);
    
    // Convert UV to NDC space
    float2 ndc;
    ndc.x = uv.x * 2.0 - 1.0;
    ndc.y = (1.0 - uv.y) * 2.0 - 1.0;
    
    // Calculate world position directly using orthographic projection
    float3 worldPosition = CameraPosition 
                         + (ndc.x * OrthoWidth * 0.5 * CameraRight) 
                         + (ndc.y * OrthoHeight * 0.5 * CameraUp)
                         + (depth * CameraForward);
    
    // Check if we hit valid geometry AND it's the target mesh
    bool didHit = isTargetMesh && (depth > 0.0 && depth < MaxRayDistance * 0.99);
    
    if (!didHit)
    {
        // No valid surface or wrong mesh - place far away
        worldPosition = float3(0, 0, -100000.0);
    }
    else
    {
        // Apply spawn probability
        float spawnRandom = Hash2D(gridSeed + float2(100.0, 200.0));
        bool shouldSpawn = spawnRandom < SpawnDensity;
        
        if (shouldSpawn)
        {
            // Add vertical offset (adjust based on your up axis)
            worldPosition += VerticalOffset * float3(0, 0, 1); // Z-up
            
            // Add random positional offset within grid cell
            float offsetX = (Hash2D(gridSeed + float2(1.0, 2.0)) - 0.5) * GridCellSize;
            float offsetY = (Hash2D(gridSeed + float2(3.0, 4.0)) - 0.5) * GridCellSize;
            
            worldPosition.x += offsetX;
            worldPosition.y += offsetY;
        }
        else
        {
            worldPosition = float3(0, 0, -100000.0);
        }
    }
    
    // Calculate random scale variation
    float scaleVariation = 0.7 + Hash2D(gridSeed + float2(7.0, 8.0)) * 0.6;
    
    // Write result
    SpawnPositions[Index] = float4(worldPosition, scaleVariation);
}